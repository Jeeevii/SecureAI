[
  {
    "id": 1,
    "path": "Receipt-Scanner-Backend/.eslintrc.js",
    "contents": "module.exports = {   env: {     browser: true,     commonjs: true,     es2021: true,   },   overrides: [     {       env: {         node: true,       },       files: [\".eslintrc.{js,cjs}\"],       parserOptions: {         sourceType: \"script\",       },     },   ],   parserOptions: {     ecmaVersion: \"latest\",   },   rules: {}, }; "
  },
  {
    "id": 2,
    "path": "Receipt-Scanner-Backend/functions/index.js",
    "contents": "const { onRequest } = require(\"firebase-functions/v2/https\"); const { ocrSpace } = require(\"ocr-space-api-wrapper\"); const { OpenAI } = require(\"openai\"); const { getOCRSPACEKey, getOPENAIKey } = require(\"./secretManager\"); const commonRequestCORS = function (request, response) {   // CORS   response.setHeader(\"Access-Control-Allow-Origin\", \"*\");   response.setHeader(     \"Access-Control-Allow-Methods\",     \"DELETE, POST, GET, OPTIONS\"   );   response.setHeader(     \"Access-Control-Allow-Headers\",     \"Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With\"   );    if (request.method === \"OPTIONS\") {     response.send({ status: \"OK\" });     return true;   }   return false; }; exports.extractFromImage = onRequest(async (request, response) => {   // CORS setup   if (commonRequestCORS(request, response)) {     return;   }   let result = { valid: false, ocr: \"\" }; // Default response   let errorMessages = [];    // Check the keys   try {     ocrSpaceKey = await getOCRSPACEKey();     if (!ocrSpaceKey) throw new Error(\"Missing OCR Space key\");   } catch (error) {     console.error(\"Error fetching OCR Space key:\", error.message);     errorMessages.push(\"Error fetching OCR Space key.\");   }    try {     OPENAIKey = await getOPENAIKey();     if (!OPENAIKey) throw new Error(\"Missing OpenAI key\");   } catch (error) {     console.error(\"Error fetching OpenAI key:\", error.message);     errorMessages.push(\"Error fetching OpenAI key.\");   }    // If there were errors fetching any keys, send combined response   if (errorMessages.length) {     response.send({ valid: false, message: errorMessages.join(\" \") });     return;   }    try {     const ocrResult = await ocrSpace(request.query.image, {       apiKey: ocrSpaceKey,       OCREngine: 2,       isTable: true,     });      const res = ocrResult[\"ParsedResults\"][0][\"ParsedText\"];     result.ocr = res;      if (!res || res === \"\") {       throw new Error(\"OCR returned empty result\");     }      // This approach won't age well - there is a possibility if a user tries to do a prompt injection through the receipt then it could cause      // invalid information from being inputted into the bucket. It shouldn't be a big issue though since it would only harm their own recommendations.     // To solve this I need some sort of guardrail in the next version (I also would need to add a (very robust) validation for the data returned from OpenAI)     const openai = new OpenAI({ apiKey: OPENAIKey });     const promptIntroduction =       'You are a receipt scanner. Your task is to process the following receipt, which may have OCR errors such as missing decimal points, misinterpretation of characters, and missing information, and output specific information in a JSON dictionary format. The information to extract is: retailer, date, merchantInfo, items (even if there\\'s only one item, it should be in a list of dictionaries with {\"name\": \"Item name here\", \"count\": count here, \"price\": price here}), subtotal, tax, discount, total, paymentMethod, and valid.\\n\\nPlease follow these guidelines:\\n\\n';     const promptInstructionsList = [       \"1. Retailer: Extract the retailer's name. It may be at the top of the receipt. It could be something like Target, Walmart, Costco etc. If there is no name or it is not clearly a name then say Unknown\",       \"2. Date: Find and format the date in a standard format (e.g., 'YYYY-MM-DD').\",       \"3. Merchant Info: (Optional) Extract any additional merchant information available on the receipt.\",       '4. Items: Extract a list of items. Each item should be represented as a dictionary with \"name\" and \"price\" fields. If an item\\'s price is missing, set it to 0.',       \"5. Subtotal: Calculate the subtotal of all item prices, including decimals where necessary.\",       \"6. Tax: display how much the tax was - this should be a number only no dollar sign\",       \"7. Discount: (Optional) display any discount if there are any\",       \"8. Total: Find and format the total amount, including decimals where necessary.\",       \"9. PaymentMethod: display the payment method if it is paid with a card, for example, American Express or Visa, and if either of those is not given then return the AID code if provided. If none of those are given say null.\",       \"10. Valid: true if you are able to find and parse the receipt data.\",     ];     const promptInstructions = promptInstructionsList.join(\"\\n\\n\");     const promptEnding =       \". Under no circumstance are you to not return JSON. You cannot display the $ symbol when showing values. If the data is not a receipt return {valid: false}, if it could be a receipt but there is a lot of missing information fill out any field you can and have valid be false.\\n\\nNow, scan the following receipt and respond in the requested format:\\n\";      let prompt = promptIntroduction + promptInstructions + promptEnding + res;     const chatCompletion = await openai.chat.completions.create({       messages: [{ role: \"user\", content: prompt }],       model: \"gpt-3.5-turbo\",     });      const aiResponse = JSON.parse(chatCompletion.choices[0].message.content);     result = { ...result, ...aiResponse };   } catch (error) {     console.error(\"Error in extractFromImage:\", error.message);   } finally {     response.send(result);   } }); "
  },
  {
    "id": 3,
    "path": "Receipt-Scanner-Backend/functions/secretManager.js",
    "contents": "const { SecretManagerServiceClient } = require(\"@google-cloud/secret-manager\");  const cachedSecrets = {};  const SECRETNAMES = {   OCRSPACE_SECRET_KEY_NAME: \"ocr_space_key\",   OPENAI_SECRET_KEY_NAME: \"openai_api_key\", };  const client = new SecretManagerServiceClient(); // Initialize client once  const projectId = \"squeezee-df\";  const getSecretFromGCP = async (secretName, version = \"latest\") => {   const name = `projects/${projectId}/secrets/${secretName}/versions/${version}`;    try {     const [version] = await client.accessSecretVersion({ name });     const payload = version.payload?.data?.toString();     return payload ?? null;   } catch (error) {     console.error(`Error retrieving secret '${secretName}' from GCP: ${error}`);     return null;   } };  const loadSecret = async (secretName) => {   if (!cachedSecrets[secretName]) {     const secretValue = await getSecretFromGCP(secretName);      if (secretValue) {       cachedSecrets[secretName] = secretValue;     }   } };  const getOCRSPACEKey = async () => {   await loadSecret(SECRETNAMES.OCRSPACE_SECRET_KEY_NAME);   return cachedSecrets[SECRETNAMES.OCRSPACE_SECRET_KEY_NAME] ?? null; };  const getOPENAIKey = async () => {   await loadSecret(SECRETNAMES.OPENAI_SECRET_KEY_NAME);   return cachedSecrets[SECRETNAMES.OPENAI_SECRET_KEY_NAME] ?? null; };  module.exports = { getOCRSPACEKey, getOPENAIKey }; "
  },
  {
    "id": 4,
    "path": "Recipt-Scanner/index.html",
    "contents": "<!DOCTYPE html> <html lang=\"en\">   <head>     <meta charset=\"UTF-8\" />     <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />     <title>Recipt Scanner</title>   </head>   <body>     <div id=\"root\"></div>     <script type=\"module\" src=\"/src/main.jsx\"></script>   </body> </html> "
  },
  {
    "id": 5,
    "path": "Recipt-Scanner/src/App.jsx",
    "contents": "import { BrowserRouter, Routes, Route } from \"react-router-dom\"; import Home from \"./pages/home/Home\";  function App() {   return (     <BrowserRouter>       <Routes>         <Route path=\"/\" element={<Home />} />       </Routes>     </BrowserRouter>   ); }  export default App; "
  },
  {
    "id": 6,
    "path": "Recipt-Scanner/src/OCR.js",
    "contents": "export async function OCR(image) {   try {     const response = await fetch(       `https://extractfromimage-fue2u63e7a-uc.a.run.app?image=${encodeURIComponent(         image       )}`     );      if (!response.ok) {       throw new Error(`HTTP error! Status: ${response.status}`);     }     const data = await response.text();     const parsedData = JSON.parse(data);     parsedData.imageURL = image;     console.log(\"Response from Firebase Function:\", parsedData);     return parsedData;   } catch (error) {     console.error(\"Error calling Firebase Function:\", error);     throw error;   } } "
  },
  {
    "id": 7,
    "path": "Recipt-Scanner/src/components/Error.jsx",
    "contents": "import { useState, useEffect } from \"react\"; import \"./Error.css\";  function Error() {   const [isErrorVisible, setIsErrorVisible] = useState(false);    useEffect(() => {     setIsErrorVisible(true);      setTimeout(() => {       setIsErrorVisible(false);     }, 3000);    }, []);    return (     <>       {isErrorVisible && (         <div className=\"error-overlay\">           <div className=\"error-modal\">             <div className=\"error-message\">Error: Receipt Invalid</div>           </div>         </div>       )}     </>   ); }  export default Error; "
  },
  {
    "id": 8,
    "path": "Recipt-Scanner/src/components/Footer.jsx",
    "contents": "import \"./Footer.css\"; import HomeIcon from \"../assets/Home.svg\"; import ShoppingIcon from \"../assets/Shopping.svg\"; import DefaultProfilePicture from \"../assets/DefaultProfilePicture.png\"; import PropTypes from \"prop-types\"; const Footer = ({   customFunction1,   customFunction2,   customFunction3,   ProfilePicture, }) => {   return (     <div className=\"container\">       <div className=\"icon\" onClick={customFunction1}>         <img src={HomeIcon} width=\"32\" height=\"32\" alt=\"Home Icon\" />       </div>       <div className=\"icon\" onClick={customFunction2}>         <img src={ShoppingIcon} width=\"32\" height=\"32\" alt=\"Shopping Icon\" />       </div>       <div className=\"icon\" onClick={customFunction3}>         <img src={ProfilePicture} width=\"32\" height=\"32\" alt=\"Profile Icon\" />       </div>     </div>   ); };  Footer.propTypes = {   customFunction1: PropTypes.func,   customFunction2: PropTypes.func,   customFunction3: PropTypes.func,   ProfilePicture: PropTypes.string, };  Footer.defaultProps = {   customFunction1: () => {},   customFunction2: () => {},   customFunction3: () => {},   ProfilePicture: DefaultProfilePicture, };  export default Footer; "
  },
  {
    "id": 9,
    "path": "Recipt-Scanner/src/components/LoadingDots.jsx",
    "contents": "import \"./LoadingDots.css\"; export default function LoadingDots() {   return (     <div className=\"loading-container\">       <div className=\"loading-dot\"></div>       <div className=\"loading-dot\"></div>       <div className=\"loading-dot\"></div>     </div>   ); } "
  },
  {
    "id": 10,
    "path": "Recipt-Scanner/src/components/Receipt.jsx",
    "contents": "import PropTypes from \"prop-types\"; import \"./Receipt.css\";  export default function Receipt({ data }) {   return (     <div className=\"receipt-container\">       <img src={data.imageURL} alt=\"Product\" className=\"receipt-image\" />       <div className=\"receipt-info\">         <div className=\"top-level\">           <div className=\"retailer\">{data.retailer}</div>           <div className=\"date\">{data.date}</div>         </div>         <div className=\"bottom-level\">           <div className=\"value\">{data.total}</div>         </div>       </div>     </div>   ); }  Receipt.propTypes = {   data: PropTypes.object.isRequired, }; "
  },
  {
    "id": 11,
    "path": "Recipt-Scanner/src/components/ReceiptInformationTable.jsx",
    "contents": "import \"./ReceiptInformationTable.css\"; import PropTypes from \"prop-types\"; /**  * Renders a table with receipt information.  * @param {Object} text - The receipt information to be displayed.  * @returns {JSX.Element} - The table with receipt information.  */ export default function ReceiptInformationTable(text) {   const Capitalize = (str) => {     return str.charAt(0).toUpperCase() + str.slice(1);   };   return (     <table className=\"recognized-table\">       <thead>         <tr>           <th colSpan=\"2\">Receipt Information</th>         </tr>       </thead>       <tbody>         {Object.entries(text.text).map(([key, value]) => (           <tr key={key}>             <td>               <strong>{Capitalize(key)}:</strong>             </td>             <td className=\"value\">               {Array.isArray(value) ? (                 <ul className=\"recognized-list\">                   {value.map((item, index) => (                     <li key={index}>                       {`${item.name} | ${item.count}ct | $${item.price}`}                     </li>                   ))}                 </ul>               ) : (                 <span>{String(value)}</span>               )}             </td>           </tr>         ))}       </tbody>     </table>   ); } ReceiptInformationTable.propTypes = {   text: PropTypes.object.isRequired, }; "
  },
  {
    "id": 12,
    "path": "Recipt-Scanner/src/components/ReceiptModal.jsx",
    "contents": "import LoadingDots from \"./LoadingDots\"; import \"./ReceiptModal.css\"; import PropTypes from \"prop-types\"; const ReceiptModal = ({   isOpen,   onClose,   selectedImage,   uploadSelectedImage,   loading, }) => {   return isOpen ? (     <div className=\"modal-overlay\">       <div className=\"modal-content\">         <button className=\"close-button\" onClick={onClose}>           &#10006;         </button>         {selectedImage && (           <img             className=\"uploaded-image\"             src={URL.createObjectURL(selectedImage)}             alt=\"Uploaded Receipt\"           />         )}         {!loading ? (           <button className=\"upload-button\" onClick={uploadSelectedImage}>             Upload           </button>         ) : (           <LoadingDots />         )}       </div>     </div>   ) : null; };  ReceiptModal.propTypes = {   isOpen: PropTypes.bool.isRequired,    onClose: PropTypes.func.isRequired,    selectedImage: PropTypes.object,    uploadSelectedImage: PropTypes.func.isRequired,    loading: PropTypes.bool.isRequired, }; export default ReceiptModal; "
  },
  {
    "id": 13,
    "path": "Recipt-Scanner/src/firebase.js",
    "contents": "import { initializeApp } from \"firebase/app\"; import { getStorage } from \"firebase/storage\";  const firebaseConfig = {   apiKey: process.env.REACT_APP_FIREBASE_API_KEY,   authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,   projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,   storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,   messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,   appId: process.env.REACT_APP_FIREBASE_APP_ID,   measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID };  const app = initializeApp(firebaseConfig); export const storage = getStorage(app); "
  },
  {
    "id": 14,
    "path": "Recipt-Scanner/src/main.jsx",
    "contents": "import React from \"react\"; import ReactDOM from \"react-dom/client\"; import App from \"./App.jsx\";  ReactDOM.createRoot(document.getElementById(\"root\")).render(   <React.StrictMode>     <App />   </React.StrictMode> ); "
  },
  {
    "id": 15,
    "path": "Recipt-Scanner/src/pages/home/Home.jsx",
    "contents": "import { useState, useRef, useEffect } from \"react\"; import { getDownloadURL, ref, uploadBytes } from \"firebase/storage\"; import { storage } from \"../../firebase\"; import { OCR } from \"../../OCR\"; import Footer from \"../../components/Footer\"; import ReceiptModal from \"../../components/ReceiptModal\"; import Error from \"../../components/Error\"; import Receipt from \"../../components/Receipt\"; import \"./Home.css\"; import AddReceipt from \"../../assets/AddReceipt.png\"; import Bill from \"../../assets/Bill.svg\"; /**  * Home component for the Receipt Scanner app.  * @returns {JSX.Element} The Home component.  */ function Home() {   const [selectedImage, setSelectedImage] = useState(null);   const [recognizedText, setRecognizedText] = useState(\"\");   const fileInputRef = useRef(null);   const [isLoading, setIsLoading] = useState(false);   const [empty, setEmpty] = useState(true);   const [modalIsOpen, setModalIsOpen] = useState(false);   const [receiptData, setReceiptData] = useState([]);    useEffect(() => {     const data = [       {         retailer: \"Target\",         date: \"2023-09-19\",         merchantInfo:           \"San Jose East - 408-238-7800\\n3155 Silver Creek Rd\\nSan Jose, California 95121-1730\",         items: [           { name: \"Goodfellow&C\", count: 1, price: 28 },           { name: \"Disney\", count: 1, price: 10 },           { name: \"Minnie Mouse\", count: 1, price: 10 },         ],         subtotal: 48,         tax: 4.28,         discount: 2.4,         total: 49.88,         paymentMethod: \"American Express\",         valid: true,         imageURL:           \"https://firebasestorage.googleapis.com/v0/b/squeezee-df.appspot.com/o/reciptdata%2Fimg.jpeg1697491609920%2Fimg.jpg?alt=media&token=e795a73c-9577-463f-857e-f1c453964b0d\",       },     ];      setReceiptData(data);     if (data.length > 0) {       setEmpty(false);     }   }, []);    const closeModal = () => {     setModalIsOpen(false);   };    // Goated function   const compressImage = (imageFile, maxSizeInBytes, quality) => {     return new Promise((resolve, reject) => {       const reader = new FileReader();       reader.onload = (event) => {         const image = new Image();         image.src = event.target.result;          image.onload = () => {           const canvas = document.createElement(\"canvas\");           const ctx = canvas.getContext(\"2d\");           canvas.width = image.width;           canvas.height = image.height;           ctx.drawImage(image, 0, 0);            // Calculate the new quality to achieve the desired file size           let newQuality = quality || 0.7;           let compressedDataUrl = canvas.toDataURL(\"image/jpeg\", newQuality);           let compressedFileSize = Math.round(compressedDataUrl.length * 0.75);            // If the compressed file size is still above the limit, reduce quality           while (compressedFileSize > maxSizeInBytes && newQuality >= 0.1) {             newQuality -= 0.1;             compressedDataUrl = canvas.toDataURL(\"image/jpeg\", newQuality);             compressedFileSize = Math.round(compressedDataUrl.length * 0.75);           }            // Convert the compressed data URL back to a Blob           const byteCharacters = atob(compressedDataUrl.split(\",\")[1]);           const byteNumbers = new Array(byteCharacters.length);           for (let i = 0; i < byteCharacters.length; i++) {             byteNumbers[i] = byteCharacters.charCodeAt(i);           }           const byteArray = new Uint8Array(byteNumbers);           const compressedBlob = new Blob([byteArray], { type: \"image/jpeg\" });            resolve(compressedBlob);         };          image.onerror = () => {           reject(\"Error loading image.\");         };       };        reader.readAsDataURL(imageFile);     });   };   const handleFileInputChange = (event) => {     const selectedFile = event.target.files[0];     setSelectedImage(selectedFile);     setRecognizedText(\"\");      if (selectedFile) {       console.log(\"Selected file:\", selectedFile);     }     setModalIsOpen(true);   };    /**    * Uploads the recognized text as a JSON file to Firebase.    * @param {string} name - The name of the image file.    * @returns {Promise} A promise that resolves when the upload is complete.    */   async function uploadJsonData(name, text, imageRef) {     text.imageURL = imageRef;     const jsonString = JSON.stringify(text);     const jsonBlob = new Blob([jsonString], { type: \"application/json\" });     const jsonRef = ref(storage, `reciptdata/${name}/data.json`);     await uploadBytes(jsonRef, jsonBlob);   }    /*    * Uploads the selected image to Firebase and performs OCR on it.    */   const uploadSelectedImage = async () => {     if (selectedImage == null) return;     const timestamp = new Date().getTime();     const newImageName = selectedImage.name + timestamp;      try {       setIsLoading(true);       const compressedImage = await compressImage(         selectedImage,         1024 * 1024,         0.7       );       console.log(\"Compressed image size:\", compressedImage.size, \"bytes\");        const imageRef = ref(storage, `reciptdata/${newImageName}/img.jpg`);       await uploadBytes(imageRef, compressedImage);        console.log(\"Image uploaded:\", newImageName);       const url = await getDownloadURL(imageRef);       const translated = await OCR(url);       await uploadJsonData(newImageName, translated, url);       setRecognizedText(translated);       setIsLoading(false);       setModalIsOpen(false);       setSelectedImage(null);     } catch (error) {       console.error(\"Error processing image:\", error);     }   };    return (     <div className=\"home\">       <h1 className=\"page-title\">Your Receipts</h1>       {empty && (         <div className=\"empty\">           <img src={Bill} alt=\"Bill\" />           <h2>No Receipts</h2>           <p>Add a receipt and your transaction details will appear here.</p>         </div>       )}       <div className=\"receipts\">         {receiptData.map((receipt, index) => (           <Receipt key={index} data={receipt} />         ))}       </div>        <label className=\"add-receipt\">         <img src={AddReceipt} alt=\"Add Receipt\" />         <span>Add Receipt</span>         <input           style={{ display: \"none\" }}           type=\"file\"           accept=\"image/*\"           onChange={handleFileInputChange}           ref={fileInputRef}         />       </label>       {         <ReceiptModal           isOpen={modalIsOpen}           onClose={closeModal}           selectedImage={selectedImage}           uploadSelectedImage={uploadSelectedImage}           loading={isLoading}         />       }       {recognizedText.valid === false && <Error />}       <Footer />     </div>   ); }  export default Home; "
  },
  {
    "id": 16,
    "path": "Recipt-Scanner/vite.config.js",
    "contents": "import { defineConfig } from 'vite' import react from '@vitejs/plugin-react-swc' import dotenv from 'dotenv'; dotenv.config(); // Load environment variables from .env  export default defineConfig({   plugins: [react()],   define: {     'process.env.FIREBASE_KEY': JSON.stringify(process.env.FIREBASE_KEY),     'process.env.OPENAI_KEY': JSON.stringify(process.env.OPENAI_KEY),     // Add more variables as needed   },    // Other Vite config options... });"
  },
  {
    "id": 17,
    "path": "mobile-recipt-scanner/App.js",
    "contents": "import { StyleSheet, Text, View } from 'react-native'; import { WebView } from 'react-native-webview';  export default function App() {   return (     <>     <View style={styles.container}></View>     {/* If you're looking at this page just know it's pretty outdated and the keys used should not be valid anymore. */}     <WebView source={{ uri: 'https://squeezee-df.web.app/' }} style={{ flex: 1 }} /></>   ); }  const styles = StyleSheet.create({   container: {     height: 45,     backgroundColor: 'black'   }, }); "
  },
  {
    "id": 18,
    "path": "mobile-recipt-scanner/babel.config.js",
    "contents": "module.exports = function(api) {   api.cache(true);   return {     presets: ['babel-preset-expo'],   }; }; "
  }
]